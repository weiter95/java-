# 3-15笔记 #

#### 线程创建的两种方式对比 ####
- 创建thread的子类有类的单继承的局限性，存在线程对象和执行单元的耦合性问题
- 实现runnable接口可以多实现，解决了线程对象和执行单元的耦合性问题。可以数据共享！

#### 多线程安全问题 ####
1. 使用runnable接口启动多个线程，如果run()方法中对数据共同操作（数据共享），将会出现安全问题，因为cpu切换线程的随机性，比如，当thread-1获得cpu执行权，开始进入run方法中执行，当执行到if(a>0)时，后面代码还没执行完全，cpu可能会切换到thread-2线程，这时thread-2获得到了cpu执行权，开始进入run方法，加入现在a已经变成1；这时还是符合if条件，判断完之后，可能这时cpu又切换到了thread-1，这时候开始打印a--，a现在变成0了；执行完，切换到thread-2，这时候，开始打印，结果为-1，这就违背我们的意愿，
代码如下：
	`int a =100;
	if (a>0){
	system.out.println(a--);
	}  `

	`synchronized（类对象）{
		if (a>0){
		system.out.println(a--);
		} 
	}`

2. 解决办法  加上同步锁各个线程都会一开始先去拿“类对象”，如果有“类对象”，就会进去里面执行代码，同时也会持有“类对象”，这时，其他线程是拿不到“类对象”的，只有等到上一线程执行完，才会把“类对象”还回来，就相当于上了锁，只允许一个线程进入并等到该线程执行完，其他线程才能进入，这样就解决了多线程安全问题，   同时，**它的弊端就是消耗cpu资源，假如现在有一线程拿到“类对象”开始执行代码，这时，cpu切换了线程，其他线程一开始会去拿“类对象”，可这时，类对象被上一线程持有，它无法执行下面的代码，然后cpu就会切换到其他线程，依旧判断，最后重新切回持有类对象的线程，等待该线程执行完全，其他线程才可能获得到类对象**但比起消耗cpu资源，我们更愿意牺牲它，来获得程序安全！

3. 使用同步的前提：***多个线程在同步中必须使用同一个锁，才能对多个线程同步，也就是必须有多个线程，而且它们存在数据共享，***  
4. 注意事项：synchronized（）括号里面的对象必须是多个线程同时用一个类对象，不能每个线程都能持有，比如synchronized（new 。。。），这样完全没有意义，相当于没加同步锁
  
### Stringbuffer特点 ###
1. 长度可以变化
2. 可以对元素进行增删改查（通过指定方法进行操作，如果方法中参数存在索引，遵循一个原则，包含头，不包含尾，比如...（1,5，“撒旦法”），参数一，包含它索引对应的值，参数二，不包含它索引对应的值，包含到它前一个索引对应的值）
3. 是个容器，是个缓冲区容器
4. 可以储存不同类型的数据
5. 最终缓冲区储存完的数据都会转变成字符串 

git clone git@github.com:weiter95/java-.git  克隆一个github上面的项目到本地
